#ifndef STATESPACECONTROLLER_H
#define STATESPACECONTROLLER_H

#include <iostream>
#include <vector>
#include <fstream>
#include <string>

#include "QSMatrix.h"

/*
 * General State-Space Controller class.
 * 
 * See "example_StateSpaceController.cpp.example" to have an implementation example.
 * 
 *               StateSpaceController class
 *           ______________/\______________
 *          /       ___        ________    \  _____^___
 *             r  +/   \  e   |        |  u  |        |   y
 *           ---->|     |---->|   K    |---->| Plant  |---+-->  
 *                 \___/      |________|     |________|   |
 *                   ^ -                                  |
 *                 y |____________________________________|
 * 
 *      K:
 *          | x_{i+1} = A*x_i + B*e_i
 *          |     u_i = C*x_i + D*e_i
 *
 *              with e_i = r_i - y_i    
 */

/*
     * Constructor from file.dat : useful to import data from controller synthesis
     * 
     * formattedDataFilePath : Path to the file
     * 
     * The file has to be formatted as follows:
     * 
     * -------FILE_BEGIN-------
     * Time step value (seconds) (example : 0.1)
     * State vector dimension nx
     * Error vector dimension ne (example : 2)
     * Controller output vector dimension nu
     * A[0,0] value (example : 12.354)
     * ...
     * A[0,nx]
     * A[1,0]
     * ...
     * A[1,nx]
     * ...
     * A[nx,nx]
     * B[0,0] value (example : 12.354)
     * ...
     * B[0,ne]
     * B[1,0]
     * ...
     * B[1,ne]
     * ...
     * B[nx,ne]
     * C[0,0] value (example : 12.354)
     * ...
     * C[0,nx]
     * C[1,0]
     * ...
     * C[1,nx]
     * ...
     * C[nu,nx]
     * D[0,0] value (example : 12.354)
     * ...
     * D[0,ne]
     * D[1,0]
     * ...
     * D[1,ne]
     * ...
     * D[nu,ne]
     * -------FILE_END-------
     */

class StateSpaceController
{
	public:
	
    // Default constructor
	StateSpaceController();
    
    // Constructor using QSMatrices (must be included in the program)
	StateSpaceController(QSMatrix<double> A, QSMatrix<double> B, QSMatrix<double> C, QSMatrix<double> D, double t_s);
    
    // Constructor from controller.dat : useful to import data generated by Octave/Matlab
    // See the help to see how to generate a well formatted file
    StateSpaceController(std::string formattedDataFilePath);
    
    // Construction of a controller from another controller
	StateSpaceController(StateSpaceController const& other);
    
    // Change data of the controller from a data file
    // See the help to see how to generate a well formatted file
    void loadControllerData(std::string formattedDataFilePath);
    
    // Equal operator
    StateSpaceController& operator=(const StateSpaceController& controller);
    
    /* Compute the output of the controller for one iteration (to send to the plant) and update the timer
     * 
     * With or without saturation (u_min and u_max)
     * e_i: error vector (the comparator is not used)
     * OR
     * r_i: reference signal
     * y_i: measured output of the plant
     * --> the comparator is used to generate the error vector
     * 
     * These methods return the controller output vector (u_i vector)
     */ 
    std::vector<double> currentOutput(const std::vector<double>& e_i);
    std::vector<double> currentOutput(const std::vector<double>& e_i, const std::vector<double>& u_min, const std::vector<double>& u_max);
    std::vector<double> currentOutput(const std::vector<double>& e_i, const double& u_min, const double& u_max);
    std::vector<double> currentOutput(const std::vector<double>& r_i, const std::vector<double>& y_i);
    std::vector<double> currentOutput(const std::vector<double>& r_i, const std::vector<double>& y_i, const std::vector<double>& u_min, const std::vector<double>& u_max);
    std::vector<double> currentOutput(const std::vector<double>& r_i, const std::vector<double>& y_i, const double& u_min, const double& u_max);
	
    // help method
	static void help();
	
	// State-space matrices
	QSMatrix<double> getA() const;
	void setA(QSMatrix<double> A);
    QSMatrix<double> getB() const;
	void setB(QSMatrix<double> B);
    QSMatrix<double> getC() const;
	void setC(QSMatrix<double> C);
    QSMatrix<double> getD() const;
	void setD(QSMatrix<double> D);
    
    // Time step (seconds)
    double getTimeStep() const;
	void setTimeStep(double t_s);
    
    // Current time (seconds)
    double getTime() const;
    
    // State vector dimension
    int getNx() const;
    
    // Error vector dimension (input)
    int getNe() const;
    
    // Output vector dimension
    int getNu() const;
    
    // Current state vector
    std::vector<double> getX_i() const;
	
	// Print the state-space representation of the controller
	void printSS() const;
    
    // Print all vectors of the current state of the controller (time, r, y, e, u, x)
    void printState() const;
    
    // Export the state-space representation to string
    std::string getSS() const;
    
    // Reset time and states (to zero)
    void reset();
	
	protected:
    // Compute the next state vector
    void nextState();  // gives x_ip1 (x i+1)
    
    // Compute the current error from reference r and plant output y
    void currentError();
    
    // Limit the controller output if saturation values have been provided
    void saturation(const std::vector<double>& min, const std::vector<double>& max); // Limit the output of the controller
    void saturation(const double& u_min, const double& u_max);  // Use when there is only 1 min/max for all controller outputs.
        
    
    // State-space matrices
	QSMatrix<double> m_A;
	QSMatrix<double> m_B;
    QSMatrix<double> m_C;
	QSMatrix<double> m_D;
    double m_t_s;   // Time step of the controller
    int m_i;   // Indice of the current time
    double m_t;     // Current time
    
    
	int m_nx; // State vector dimension
	int m_ne; // Error vector dimension
	int m_nu; // Controller output vector dimension
    std::vector<double> m_x_i;    // Current state
    std::vector<double> m_x_ib; // Backup of the last state for display
    std::vector<double> m_r_i;    // Current reference signal
    std::vector<double> m_y_i;    // Current global system output
    std::vector<double> m_e_i;    // Current error
    std::vector<double> m_u_i;    // Current output
};

#endif

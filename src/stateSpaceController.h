/**
 * @file stateSpaceController.h
 * @brief StateSpaceController class header.
 * @author Alexis Proux
 * @date 1 July 2021
 ******/

#ifndef STATESPACECONTROLLER_H
#define STATESPACECONTROLLER_H

#include <iostream>
#include <vector>
#include <fstream>
#include <string>

#include "QSMatrix.h"

/*
 * General State-Space Controller class.
 * 
 * See "example_StateSpaceController.cpp.example" to have an implementation example.
 * 
 *               StateSpaceController class
 *           ______________/\______________
 *          /       ___        ________    \  ________
 *             r  +/   \  e   |        |  u  |        |   y
 *           ---->|     |---->|   K    |---->| Plant  |---+-->  
 *                 \___/      |________|     |________|   |
 *                   ^ -                                  |
 *                 y |____________________________________|
 * 
 *      K:
 *          | x_{i+1} = A*x_i + B*e_i
 *          |     u_i = C*x_i + D*e_i
 *
 *              with e_i = r_i - y_i    
 */

/*
     * Constructor from file.dat : useful to import data from controller synthesis
     * 
     * formattedDataFilePath : Path to the file
     * 
     * The file has to be formatted as follows:
     * 
     * -------FILE_BEGIN-------
     * Time step value (seconds) (example : 0.1)
     * State vector dimension nx
     * Error vector dimension ne (example : 2)
     * Controller output vector dimension nu
     * A[0,0] value (example : 12.354)
     * ...
     * A[0,nx]
     * A[1,0]
     * ...
     * A[1,nx]
     * ...
     * A[nx,nx]
     * B[0,0] value (example : 12.354)
     * ...
     * B[0,ne]
     * B[1,0]
     * ...
     * B[1,ne]
     * ...
     * B[nx,ne]
     * C[0,0] value (example : 12.354)
     * ...
     * C[0,nx]
     * C[1,0]
     * ...
     * C[1,nx]
     * ...
     * C[nu,nx]
     * D[0,0] value (example : 12.354)
     * ...
     * D[0,ne]
     * D[1,0]
     * ...
     * D[1,ne]
     * ...
     * D[nu,ne]
     * -------FILE_END-------
     */

/**
 * @class StateSpaceController
 * @brief General State-Space Controller class.
 * @details See "example_StateSpaceController.cpp.example" to have an implementation example.
 * 
 * Assuming K is the controller:
 * 
 *      K:
 * 
 *          | x_{i+1} = A*x_i + B*e_i
 *          |     u_i = C*x_i + D*e_i
 *
 *              with e_i = r_i - y_i  
 * 
 * QSMatrix class can be totally unused by user if a data file is generated to import the controller matrices.
 * See loadControllerData() or StateSpaceController::StateSpaceController() for file format and more details.
 * 
 * This class can be used as a state space controller alone or coupled with a comparator to generate the error vector by using overloaded member functions.
 ******/
template <typename T>
class StateSpaceController
{
	public:
	
    // Default constructor
	StateSpaceController();
    
    // Constructor using QSMatrices (must be included in the program)
	StateSpaceController(QSMatrix<T> A, QSMatrix<T> B, QSMatrix<T> C, QSMatrix<T> D, const float t_s);
    
    // Constructor from controller.dat : useful to import data generated by Octave/Matlab
    // See the help to see how to generate a well formatted file
    StateSpaceController(std::string formattedDataFilePath);
    
    // Construction of a controller from another controller
	StateSpaceController(StateSpaceController<T> const& other);

    virtual ~StateSpaceController();
    
    // Change data of the controller from a data file
    // See the help to see how to generate a well formatted file
    void loadControllerData(std::string formattedDataFilePath);
    
    // Equal operator
    StateSpaceController<T>& operator=(const StateSpaceController<T>& controller);
    
    /* Compute the output of the controller for one iteration (to send to the plant) and update the timer
     * 
     * With or without saturation (u_min and u_max)
     * e_i: error vector (the comparator is not used)
     * OR
     * r_i: reference signal
     * y_i: measured output of the plant
     * --> the comparator is used to generate the error vector
     * 
     * These methods return the controller output vector (u_i vector)
     */ 
    std::vector<T> currentOutput(const std::vector<T>& e_i);
    std::vector<T> currentOutput(const std::vector<T>& e_i, const std::vector<T>& u_min, const std::vector<T>& u_max);
    std::vector<T> currentOutput(const std::vector<T>& e_i, const T& u_min, const T& u_max);
    std::vector<T> currentOutput(const std::vector<T>& r_i, const std::vector<T>& y_i);
    std::vector<T> currentOutput(const std::vector<T>& r_i, const std::vector<T>& y_i, const std::vector<T>& u_min, const std::vector<T>& u_max);
    std::vector<T> currentOutput(const std::vector<T>& r_i, const std::vector<T>& y_i, const T& u_min, const T& u_max);
	
    // help method
	static void help();
	
	// State-space matrices
	QSMatrix<T> getA() const;
	void setA(QSMatrix<T> A);
    QSMatrix<T> getB() const;
	void setB(QSMatrix<T> B);
    QSMatrix<T> getC() const;
	void setC(QSMatrix<T> C);
    QSMatrix<T> getD() const;
	void setD(QSMatrix<T> D);
    
    // Time step (seconds)
    float getTimeStep() const;
	void setTimeStep(const float t_s);

    // Current time (seconds)
    float getTime() const;
    
    // State vector dimension
    unsigned int getNx() const;
    
    // Error vector dimension (input)
    unsigned int getNe() const;
    
    // Output vector dimension
    unsigned int getNu() const;
    
    // Current state vector
    std::vector<T> getX_i() const;
	
	// Print the state-space representation of the controller
	void printStateSpace() const;
    
    // Print all vectors of the current state of the controller (time, r, y, e, u, x)
    void printState() const;
    
    // Export the state-space representation to string
    std::string getStateSpace() const;
    
    // Reset time and states (to zero)
    void reset();
	
	protected:
    // Compute the next state vector
    void nextState();  // gives x_ip1 (x i+1)
    
    // Compute the current error from reference r and plant output y
    void currentError();
    
    // Limit the controller output if saturation values have been provided
    void saturation(const std::vector<T>& min, const std::vector<T>& max); // Limit the output of the controller
    void saturation(const T& u_min, const T& u_max);  // Use when there is only 1 min/max for all controller outputs.
        
    
    // State-space matrices
    /**
     * @brief Controller A matrix in state space representation.
     ******/
	QSMatrix<T> m_A;
    /**
     * @brief Controller B matrix in state space representation.
     ******/
	QSMatrix<T> m_B;
    /**
     * @brief Controller C matrix in state space representation.
     ******/
    QSMatrix<T> m_C;
    /**
     * @brief Controller D matrix in state space representation.
     ******/
	QSMatrix<T> m_D;
    
    /**
     * @brief Time step of the controller (seconds).
     ******/
    float m_t_s;
    
    /**
     * @brief Indice of the current state.
     * @details Automatically incremented on each StateSpaceController::currentOutput() call.
     ******/
    unsigned int m_i;
    
    /**
     * @brief Current time (seconds).
     * @details Automatically incremented on each StateSpaceController::currentOutput() call.
     ******/
    float m_t;
    
    /**
     * @brief State vector dimension.
     ******/
	unsigned int m_nx;
	
	/**
     * @brief Error vector dimension.
     ******/
	unsigned int m_ne;
	
	/**
     * @brief Controller output vector dimension.
     ******/
	unsigned int m_nu;
	
	/**
     * @brief Current state vector.
     ******/
    std::vector<T> m_x_i;
    
    /**
     * @brief Last state vector.
     ******/
    std::vector<T> m_x_ib;
    
    /**
     * @brief Current reference signal vector.
     ******/
    std::vector<T> m_r_i;
    
    /**
     * @brief Current global plant output vector.
     ******/
    std::vector<T> m_y_i;
    
    /**
     * @brief Current error vector.
     ******/
    std::vector<T> m_e_i;
    
    /**
     * @brief Current controller output vector.
     ******/
    std::vector<T> m_u_i;
};

#include "stateSpaceController.cpp"

#endif  // STATESPACECONTROLLER_H
